<script>
(function () {
  // ---------- CONFIGURACI√ìN SUPABASE ----------
  const SUPABASE_URL = 'https://ossugwjyowdinerfnyam.supabase.co';
  const SUPABASE_ANON_KEY = 'eyJhbGciOiJIUzI1NiIsInR5cCI6IkpXVCJ9.eyJpc3MiOiJzdXBhYmFzZSIsInJlZiI6Im9zc3Vnd2p5b3dkaW5lcmZueWFtIiwicm9sZSI6ImFub24iLCJpYXQiOjE3NzEzODE5MzIsImV4cCI6MjA4Njk1NzkzMn0.AWT1Xw0Aw_yF8q5MrYM6o9tgTFNVNUd_4kbCAPiKuCI';
  const supabase = window.supabase.createClient(SUPABASE_URL, SUPABASE_ANON_KEY);

  // Elementos DOM
  const fileInput = document.getElementById('fileInput');
  const fileSelectedSpan = document.getElementById('fileSelected');
  const btnSubir = document.getElementById('btnSubir');
  const uploadStatus = document.getElementById('uploadStatus');
  const dropZone = document.getElementById('dropZone');
  const btnRefrescar = document.getElementById('btnRefrescar');
  const filtroSemana = document.getElementById('filtroSemana');
  const tablaBody = document.getElementById('tablaBody');
  const paginationDiv = document.getElementById('pagination');

  // Estado tabla
  let currentPage = 1;
  const rowsPerPage = 20;
  let totalRows = 0;
  let currentData = [];
  let fincasMap = new Map();
  let bloquesMap = new Map();

  // Config carga masiva
  const BATCH_SIZE = 500; // ajustable (300-2000 t√≠pico)
  const MAX_ROWS_PREVIEW_ERRORS = 25;

  // ---------- UTILIDADES ----------
  const norm = (s) =>
    String(s ?? '')
      .normalize('NFD').replace(/\p{Diacritic}/gu, '')
      .toLowerCase()
      .trim();

  function showToast(msg, isError=false) {
    uploadStatus.innerHTML = `<div class="toast ${isError ? 'error' : ''}">${msg}</div>`;
  }

  function toISODate(value) {
    // Devuelve YYYY-MM-DD o null
    if (value == null || value === '') return null;

    // Si ya es Date (XLSX con cellDates: true) [web:40][web:43]
    if (value instanceof Date && !isNaN(value)) {
      const y = value.getFullYear();
      const m = String(value.getMonth() + 1).padStart(2, '0');
      const d = String(value.getDate()).padStart(2, '0');
      return `${y}-${m}-${d}`;
    }

    // Si viene como n√∫mero serial excel (a veces)
    if (typeof value === 'number' && isFinite(value)) {
      // SheetJS suele manejar esto si cellDates: true; pero por si acaso:
      // Excel epoch: 1899-12-30 (aprox). Este fallback es b√°sico.
      const epoch = new Date(Date.UTC(1899, 11, 30));
      const date = new Date(epoch.getTime() + value * 86400000);
      if (!isNaN(date)) {
        const y = date.getUTCFullYear();
        const m = String(date.getUTCMonth() + 1).padStart(2, '0');
        const d = String(date.getUTCDate()).padStart(2, '0');
        return `${y}-${m}-${d}`;
      }
    }

    // Si viene como texto: intenta YYYY-MM-DD o DD/MM/YYYY
    const s = String(value).trim();
    // YYYY-MM-DD
    if (/^\d{4}-\d{2}-\d{2}$/.test(s)) return s;

    // DD/MM/YYYY o D/M/YYYY
    const m1 = s.match(/^(\d{1,2})[\/\-](\d{1,2})[\/\-](\d{4})$/);
    if (m1) {
      const dd = String(m1[1]).padStart(2, '0');
      const mm = String(m1[2]).padStart(2, '0');
      const yyyy = m1[3];
      return `${yyyy}-${mm}-${dd}`;
    }

    // √∫ltimo intento: Date.parse
    const parsed = new Date(s);
    if (!isNaN(parsed)) {
      const y = parsed.getFullYear();
      const m = String(parsed.getMonth() + 1).padStart(2, '0');
      const d = String(parsed.getDate()).padStart(2, '0');
      return `${y}-${m}-${d}`;
    }

    return null;
  }

  function toNumberInt(v, fallback=0) {
    if (v == null || v === '') return fallback;
    const n = parseInt(String(v).replace(/[^\d\-]/g, ''), 10);
    return Number.isFinite(n) ? n : fallback;
  }

  function toNumberFloat(v) {
    if (v == null || v === '') return null;
    const s = String(v).replace(',', '.').trim();
    const n = parseFloat(s);
    return Number.isFinite(n) ? n : null;
  }

  function calcSeveridad(row) {
    const total = (row.brotes_pos||0)+(row.hojas_adultas_pos||0)+(row.limones_pos||0)+(row.botones_pos||0)+(row.yemas_pos||0);
    return (total / 60) * 100;
  }

  function chunkArray(arr, size) {
    const out = [];
    for (let i = 0; i < arr.length; i += size) out.push(arr.slice(i, i + size));
    return out;
  }

  // ---------- CARGA DE CAT√ÅLOGOS ----------
  async function loadCatalogos() {
    const [{ data: fincas, error: e1 }, { data: bloques, error: e2 }] = await Promise.all([
      supabase.from('fincas').select('*'),
      supabase.from('bloques').select('*')
    ]);
    if (e1) console.error(e1);
    if (e2) console.error(e2);
    fincasMap.clear();
    bloquesMap.clear();
    if (fincas) fincas.forEach(f => fincasMap.set(f.id, f.nombre));
    if (bloques) bloques.forEach(b => bloquesMap.set(b.id, { nombre: b.nombre, finca_id: b.finca_id }));
  }

  function resolveFincaId(nombreFinca) {
    const needle = norm(nombreFinca);
    if (!needle) return null;

    // match exacto normalizado
    for (const [id, nombre] of fincasMap.entries()) {
      if (norm(nombre) === needle) return id;
    }
    // match ‚Äúcontiene‚Äù (fallback)
    for (const [id, nombre] of fincasMap.entries()) {
      if (norm(nombre).includes(needle) || needle.includes(norm(nombre))) return id;
    }
    return null;
  }

  // ---------- MAPEO FLEXIBLE DE COLUMNAS ----------
  // Define sin√≥nimos tolerantes
  const COLS = {
    fecha: ['3_fecha','fecha','date'],
    finca: ['4_finca','finca','farm'],
    tecnico: ['15_tecnico','tecnico','t√©cnico','encuestador'],
    lat: ['lat_6_geolocalizacion','latitud','lat','latitude'],
    lon: ['long_6_geolocalizacion','lon','long','longitud','longitude'],
    brotes: ['10_brotes_hojas','brotes','brote'],
    hojas: ['11_hojas_adultas','hojas_adultas','adultas','hojas'],
    limones: ['12_limones','limones','frutos','limon'],
    botones: ['13_botones_florales','botones','botones_florales','florales'],
    yemas: ['14_yemas','yemas']
  };

  function buildHeaderIndex(headers) {
    // headers: array de strings
    const idx = {};
    const hNorm = headers.map(h => norm(h));

    function findIndex(keys) {
      for (const k of keys) {
        const kn = norm(k);
        const i = hNorm.findIndex(h => h === kn || h.includes(kn));
        if (i !== -1) return i;
      }
      return -1;
    }

    idx.fecha = findIndex(COLS.fecha);
    idx.finca = findIndex(COLS.finca);
    idx.tecnico = findIndex(COLS.tecnico);
    idx.lat = findIndex(COLS.lat);
    idx.lon = findIndex(COLS.lon);
    idx.brotes = findIndex(COLS.brotes);
    idx.hojas = findIndex(COLS.hojas);
    idx.limones = findIndex(COLS.limones);
    idx.botones = findIndex(COLS.botones);
    idx.yemas = findIndex(COLS.yemas);

    return idx;
  }

  function validateHeaderIndex(idx) {
    const required = ['fecha', 'finca', 'lat', 'lon'];
    const missing = required.filter(k => idx[k] === -1);
    return missing;
  }

  // ---------- PARSEO CSV (PapaParse) ----------
  async function parseCSVFile(file) {
    return new Promise((resolve, reject) => {
      Papa.parse(file, {
        header: true,
        skipEmptyLines: true,
        dynamicTyping: false,
        worker: true, // para archivos grandes [web:49]
        complete: (results) => resolve(results),
        error: (err) => reject(err)
      });
    });
  }

  function csvRowsToRegistros(results) {
    const headers = results.meta.fields || [];
    const idx = buildHeaderIndex(headers);
    const missing = validateHeaderIndex(idx);
    if (missing.length) {
      throw new Error(`Faltan columnas requeridas: ${missing.join(', ')} (seg√∫n el encabezado detectado).`);
    }

    const registros = [];
    const errores = [];

    for (const row of results.data) {
      const fecha = toISODate(row[headers[idx.fecha]]);
      const nombreFinca = row[headers[idx.finca]];
      const lat = toNumberFloat(row[headers[idx.lat]]);
      const lon = toNumberFloat(row[headers[idx.lon]]);

      const brotes = toNumberInt(row[headers[idx.brotes]], 0);
      const hojas = toNumberInt(row[headers[idx.hojas]], 0);
      const limones = toNumberInt(row[headers[idx.limones]], 0);
      const botones = toNumberInt(row[headers[idx.botones]], 0);
      const yemas = toNumberInt(row[headers[idx.yemas]], 0);
      const tecnico = String(row[headers[idx.tecnico]] ?? '').trim();

      const finca_id = resolveFincaId(nombreFinca);

      // Validaciones m√≠nimas
      if (!fecha) { if (errores.length < MAX_ROWS_PREVIEW_ERRORS) errores.push(`Fila: fecha inv√°lida (${row[headers[idx.fecha]]})`); continue; }
      if (lat == null || lon == null) { if (errores.length < MAX_ROWS_PREVIEW_ERRORS) errores.push(`Fila ${fecha}: lat/lon inv√°lidos`); continue; }
      if (!finca_id) { if (errores.length < MAX_ROWS_PREVIEW_ERRORS) errores.push(`Fila ${fecha}: finca no encontrada (${nombreFinca})`); continue; }

      registros.push({
        fecha,
        finca_id,
        bloque_id: null,
        lat, lon,
        brotes_pos: brotes,
        hojas_adultas_pos: hojas,
        limones_pos: limones,
        botones_pos: botones,
        yemas_pos: yemas,
        tecnico
      });
    }

    return { registros, errores };
  }

  // ---------- PARSEO XLSX (SheetJS) ----------
  async function parseXLSXFile(file) {
    const arrayBuffer = await file.arrayBuffer();
    const workbook = XLSX.read(arrayBuffer, {
      type: 'array',
      cellDates: true // para fechas como Date [web:40][web:43]
    });
    const sheet = workbook.Sheets[workbook.SheetNames[0]];
    const rows = XLSX.utils.sheet_to_json(sheet, { header: 1, defval: '' });
    if (!rows || rows.length < 2) return { registros: [], errores: ['El Excel no tiene filas suficientes.'] };

    const headers = rows[0].map(h => String(h).trim());
    const idx = buildHeaderIndex(headers);
    const missing = validateHeaderIndex(idx);
    if (missing.length) {
      throw new Error(`Faltan columnas requeridas: ${missing.join(', ')} (seg√∫n el encabezado detectado).`);
    }

    const registros = [];
    const errores = [];

    for (let i = 1; i < rows.length; i++) {
      const r = rows[i];
      if (!r || r.every(v => String(v).trim() === '')) continue;

      const fecha = toISODate(r[idx.fecha]);
      const nombreFinca = r[idx.finca];
      const lat = toNumberFloat(r[idx.lat]);
      const lon = toNumberFloat(r[idx.lon]);

      const brotes = toNumberInt(r[idx.brotes], 0);
      const hojas = toNumberInt(r[idx.hojas], 0);
      const limones = toNumberInt(r[idx.limones], 0);
      const botones = toNumberInt(r[idx.botones], 0);
      const yemas = toNumberInt(r[idx.yemas], 0);
      const tecnico = String(r[idx.tecnico] ?? '').trim();

      const finca_id = resolveFincaId(nombreFinca);

      if (!fecha) { if (errores.length < MAX_ROWS_PREVIEW_ERRORS) errores.push(`Fila ${i+1}: fecha inv√°lida (${r[idx.fecha]})`); continue; }
      if (lat == null || lon == null) { if (errores.length < MAX_ROWS_PREVIEW_ERRORS) errores.push(`Fila ${i+1} (${fecha}): lat/lon inv√°lidos`); continue; }
      if (!finca_id) { if (errores.length < MAX_ROWS_PREVIEW_ERRORS) errores.push(`Fila ${i+1} (${fecha}): finca no encontrada (${nombreFinca})`); continue; }

      registros.push({
        fecha,
        finca_id,
        bloque_id: null,
        lat, lon,
        brotes_pos: brotes,
        hojas_adultas_pos: hojas,
        limones_pos: limones,
        botones_pos: botones,
        yemas_pos: yemas,
        tecnico
      });
    }

    return { registros, errores };
  }

  // ---------- PROCESAR ARCHIVO ----------
  async function procesarArchivo(file) {
    const ext = (file.name.split('.').pop() || '').toLowerCase();
    if (ext === 'csv') {
      const results = await parseCSVFile(file);
      if (results.errors && results.errors.length) {
        // PapaParse devuelve errores de formato; no siempre son fatales
        console.warn('PapaParse errors:', results.errors);
      }
      return csvRowsToRegistros(results);
    }
    if (ext === 'xlsx') {
      return await parseXLSXFile(file);
    }
    throw new Error('Tipo de archivo no soportado. Use .csv o .xlsx');
  }

  // ---------- SUBIDA POR LOTES ----------
  async function insertarEnLotes(registros) {
    const chunks = chunkArray(registros, BATCH_SIZE);
    let inserted = 0;

    for (let i = 0; i < chunks.length; i++) {
      showToast(`‚è≥ Insertando lote ${i+1}/${chunks.length}... (${inserted}/${registros.length})`);
      const { error } = await supabase.from('monitoreos').insert(chunks[i]); // o upsert(...) [web:51]
      if (error) throw error;
      inserted += chunks[i].length;
    }

    return inserted;
  }

  async function procesarYSubir(file) {
    showToast('‚è≥ Procesando archivo...');
    const { registros, errores } = await procesarArchivo(file);

    if (!registros.length) {
      const errText = errores.length ? `<br><small>Ejemplos de errores:<br>- ${errores.join('<br>- ')}</small>` : '';
      throw new Error('No se encontraron registros v√°lidos.' + errText);
    }

    if (errores.length) {
      // Aviso pero no bloquea
      showToast(`‚ö†Ô∏è Se omitieron filas con errores. Filas v√°lidas: ${registros.length}.<br><small>Ejemplos:<br>- ${errores.join('<br>- ')}</small>`);
    }

    const inserted = await insertarEnLotes(registros);
    showToast(`‚úÖ ${inserted} registros insertados correctamente`);
  }

  // ---------- UI CARGA ----------
  dropZone.addEventListener('click', () => fileInput.click());
  dropZone.addEventListener('dragover', (e) => e.preventDefault());
  dropZone.addEventListener('drop', (e) => {
    e.preventDefault();
    const file = e.dataTransfer.files[0];
    if (!file) return;
    const ok = file.name.toLowerCase().endsWith('.csv') || file.name.toLowerCase().endsWith('.xlsx');
    if (!ok) return alert('Solo archivos CSV o Excel (.xlsx)');
    fileInput.files = e.dataTransfer.files;
    fileSelectedSpan.textContent = `üìÑ ${file.name}`;
    btnSubir.disabled = false;
  });

  fileInput.addEventListener('change', () => {
    if (fileInput.files.length) {
      fileSelectedSpan.textContent = `üìÑ ${fileInput.files[0].name}`;
      btnSubir.disabled = false;
    } else {
      fileSelectedSpan.textContent = 'Ning√∫n archivo';
      btnSubir.disabled = true;
    }
  });

  btnSubir.addEventListener('click', async () => {
    const file = fileInput.files[0];
    if (!file) return;

    btnSubir.disabled = true;
    try {
      await procesarYSubir(file);
      await cargarDatosTabla(1);
    } catch (err) {
      console.error(err);
      showToast(`‚ùå Error: ${err.message}`, true);
    } finally {
      fileInput.value = '';
      fileSelectedSpan.textContent = 'Ning√∫n archivo';
      btnSubir.disabled = true;
    }
  });

  // ---------- TABLA DE VISUALIZACI√ìN ----------
  async function cargarDatosTabla(page = 1) {
    let query = supabase.from('monitoreos').select('*', { count: 'exact' });

    const filtro = filtroSemana.value;
    if (filtro === 'semana') {
      const d = new Date(); d.setDate(d.getDate() - 7);
      query = query.gte('fecha', d.toISOString().split('T')[0]);
    } else if (filtro === 'mes') {
      const d = new Date(); d.setDate(d.getDate() - 30);
      query = query.gte('fecha', d.toISOString().split('T')[0]);
    }

    const from = (page - 1) * rowsPerPage;
    const to = from + rowsPerPage - 1;
    query = query.range(from, to).order('fecha', { ascending: false });

    const { data, count, error } = await query;
    if (error) {
      console.error(error);
      tablaBody.innerHTML = `<tr><td colspan="12">Error al cargar datos</td></tr>`;
      return;
    }

    currentData = data || [];
    totalRows = count || 0;
    renderTabla();
    renderPagination(page);
  }

  function renderTabla() {
    if (currentData.length === 0) {
      tablaBody.innerHTML = `<tr><td colspan="12" style="text-align:center;">No hay datos en este per√≠odo</td></tr>`;
      return;
    }

    let html = '';
    currentData.forEach(m => {
      const sev = calcSeveridad(m).toFixed(1);
      const nombreFinca = fincasMap.get(m.finca_id) || 'Desconocida';
      let nombreBloque = '‚Äî';
      if (m.bloque_id && bloquesMap.has(m.bloque_id)) nombreBloque = bloquesMap.get(m.bloque_id).nombre;

      html += `<tr>
        <td>${m.fecha || ''}</td>
        <td>${nombreFinca}</td>
        <td>${nombreBloque}</td>
        <td>${m.tecnico || ''}</td>
        <td>${(m.lat!=null && Number.isFinite(m.lat)) ? Number(m.lat).toFixed(5) : ''}</td>
        <td>${(m.lon!=null && Number.isFinite(m.lon)) ? Number(m.lon).toFixed(5) : ''}</td>
        <td>${m.brotes_pos || 0}</td>
        <td>${m.hojas_adultas_pos || 0}</td>
        <td>${m.limones_pos || 0}</td>
        <td>${m.botones_pos || 0}</td>
        <td>${m.yemas_pos || 0}</td>
        <td>${sev}%</td>
      </tr>`;
    });
    tablaBody.innerHTML = html;
  }

  function renderPagination(currentPage) {
    const totalPages = Math.ceil(totalRows / rowsPerPage) || 1;
    let btns = '';
    btns += `<button class="page-btn" ${currentPage === 1 ? 'disabled' : ''} onclick="cambiarPagina(${currentPage - 1})">‚óÄ Anterior</button>`;
    let start = Math.max(1, currentPage - 2);
    let end = Math.min(totalPages, currentPage + 2);
    for (let i = start; i <= end; i++) {
      btns += `<button class="page-btn ${i === currentPage ? 'active' : ''}" onclick="cambiarPagina(${i})">${i}</button>`;
    }
    btns += `<button class="page-btn" ${currentPage === totalPages ? 'disabled' : ''} onclick="cambiarPagina(${currentPage + 1})">Siguiente ‚ñ∂</button>`;
    paginationDiv.innerHTML = btns;
  }

  window.cambiarPagina = (page) => {
    const totalPages = Math.ceil(totalRows / rowsPerPage) || 1;
    if (page < 1 || page > totalPages) return;
    currentPage = page;
    cargarDatosTabla(page);
  };

  btnRefrescar.addEventListener('click', () => {
    currentPage = 1;
    cargarDatosTabla(1);
  });

  filtroSemana.addEventListener('change', () => {
    currentPage = 1;
    cargarDatosTabla(1);
  });

  // ---------- INIT ----------
  async function init() {
    await loadCatalogos();
    await cargarDatosTabla(1);
  }
  init();
})();
</script>

