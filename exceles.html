<!DOCTYPE html>
<html lang="es">
<head>
  <meta charset="UTF-8" />
  <meta name="viewport" content="width=device-width, initial-scale=1.0" />
  <title>Cargar CSV / Excel ¬∑ Monitoreo</title>

  <!-- SheetJS (XLSX) -->
  <script src="https://cdn.sheetjs.com/xlsx-0.20.2/package/dist/xlsx.full.min.js"></script>
  <!-- PapaParse (CSV) -->
  <script src="https://cdn.jsdelivr.net/npm/papaparse@5.4.1/papaparse.min.js"></script>

  <style>
    * { box-sizing: border-box; margin: 0; padding: 0; font-family: 'Segoe UI', Roboto, sans-serif; }
    body { background: #f4f7fb; color: #1a2b3c; }
    nav { background: #1e3a5f; padding: 1rem 2rem; display: flex; gap: 2.5rem; }
    nav a { color: #e0e9f0; text-decoration: none; font-size: 1.1rem; font-weight: 600; padding: 0.4rem 0; border-bottom: 3px solid transparent; }
    nav a:hover { border-bottom-color: #8bc34a; color: white; }
    nav a.active { color: white; border-bottom-color: #ffb74d; }
    main { padding: 2rem; max-width: 1200px; margin: 0 auto; }
    h2 { margin-bottom: 1rem; font-weight: 500; }

    .card { background: white; border-radius: 22px; padding: 1.5rem; box-shadow: 0 8px 20px rgba(0,0,0,0.05); }
    .upload-area { border: 3px dashed #b8ccda; border-radius: 26px; padding: 2.2rem; text-align: center; background: #f0f8ff; margin: 1rem 0; cursor: pointer; }
    .upload-area input { display: none; }
    .label { font-weight: 800; color: #1e3a5f; text-decoration: underline; cursor: pointer; }
    .badge { display:inline-block; margin-top: .8rem; background: #d4e3fd; padding: 0.25rem 0.8rem; border-radius: 999px; font-size: 0.85rem; }
    .btn { background: #1e3a5f; color: white; border: none; padding: 0.7rem 1.4rem; border-radius: 999px; font-weight: 800; cursor: pointer; margin-top: .8rem; }
    .btn:disabled { opacity: 0.5; cursor: not-allowed; }
    .toast { padding: 1rem; border-radius: 16px; background: white; box-shadow: 0 4px 10px rgba(0,0,0,0.08); margin-top: 1rem; border-left: 6px solid #8bc34a; line-height: 1.35; }
    .toast.error { border-left-color: #e15554; }

    .muted { color:#4a5f73; font-size: 0.95rem; margin-top:.3rem; }
    code { background: #f6f8fa; padding: 0.1rem 0.35rem; border-radius: 6px; }
  </style>
</head>

<body>
  <nav>
    <a href="index.html">üåç Dashboard</a>
    <a href="informes.html">üìà Informes</a>
    <a href="exceles.html" class="active">üìé Cargar CSV/Excel</a>
    <a href="admin.html">‚öôÔ∏è Admin</a>
  </nav>

  <main>
    <h2>üìé Subir datos (se guardan en Supabase)</h2>
    <p class="muted">
      Esto guarda filas en <code>monitoreos</code>. Si subes el mismo archivo 2 veces, NO duplica gracias a <code>fingerprint</code>.
    </p>

    <div class="card">
      <div class="upload-area" id="dropZone">
        <input type="file" id="fileInput" accept=".csv,.xlsx" />
        <p>Arrastra o <span class="label" id="selectFileBtn">selecciona un CSV o XLSX</span></p>
        <div class="badge" id="fileSelected">Ning√∫n archivo</div>
      </div>

      <button class="btn" id="btnSubir" disabled>Subir a Supabase</button>
      <div id="status"></div>
    </div>
  </main>

  <script type="module">
    import { createClient } from 'https://cdn.jsdelivr.net/npm/@supabase/supabase-js/+esm';

    // ====== PEGA AQU√ç TUS DATOS ======
    const SUPABASE_URL = 'https://ossugwjyowdinerfnyam.supabase.co';
    const SUPABASE_ANON_KEY = 'eyJhbGciOiJIUzI1NiIsInR5cCI6IkpXVCJ9.eyJpc3MiOiJzdXBhYmFzZSIsInJlZiI6Im9zc3Vnd2p5b3dkaW5lcmZueWFtIiwicm9sZSI6ImFub24iLCJpYXQiOjE3NzEzODE5MzIsImV4cCI6MjA4Njk1NzkzMn0.AWT1Xw0Aw_yF8q5MrYM6o9tgTFNVNUd_4kbCAPiKuCI';
    // =================================

    const supabase = createClient(SUPABASE_URL, SUPABASE_ANON_KEY);

    const fileInput = document.getElementById('fileInput');
    const fileSelected = document.getElementById('fileSelected');
    const btnSubir = document.getElementById('btnSubir');
    const status = document.getElementById('status');
    const dropZone = document.getElementById('dropZone');
    const selectFileBtn = document.getElementById('selectFileBtn');

    const BATCH_SIZE = 500;
    const MAX_ERR_PREVIEW = 20;

    let fincasMap = new Map(); // id -> nombre

    const norm = (s) =>
      String(s ?? '').normalize('NFD').replace(/\p{Diacritic}/gu, '').toLowerCase().trim();

    function toast(html, isError=false) {
      status.innerHTML = `<div class="toast ${isError ? 'error' : ''}">${html}</div>`;
    }

    function chunkArray(arr, size) {
      const out = [];
      for (let i = 0; i < arr.length; i += size) out.push(arr.slice(i, i + size));
      return out;
    }

    function toNumberFloat(v) {
      if (v == null || v === '') return null;
      const n = parseFloat(String(v).replace(',', '.').trim());
      return Number.isFinite(n) ? n : null;
    }

    function toInt(v, fallback = 0) {
      if (v == null || v === '') return fallback;
      const n = parseInt(String(v).replace(/[^\d\-]/g, ''), 10);
      return Number.isFinite(n) ? n : fallback;
    }

    function toISODate(value) {
      if (value == null || value === '') return null;

      if (value instanceof Date && !isNaN(value)) {
        const y = value.getFullYear();
        const m = String(value.getMonth() + 1).padStart(2, '0');
        const d = String(value.getDate()).padStart(2, '0');
        return `${y}-${m}-${d}`;
      }

      if (typeof value === 'number' && isFinite(value)) {
        const epoch = new Date(Date.UTC(1899, 11, 30));
        const date = new Date(epoch.getTime() + value * 86400000);
        if (!isNaN(date)) {
          const y = date.getUTCFullYear();
          const m = String(date.getUTCMonth() + 1).padStart(2, '0');
          const d = String(date.getUTCDate()).padStart(2, '0');
          return `${y}-${m}-${d}`;
        }
      }

      const s = String(value).trim();
      if (/^\d{4}-\d{2}-\d{2}$/.test(s)) return s;

      const m1 = s.match(/^(\d{1,2})[\/\-](\d{1,2})[\/\-](\d{4})$/);
      if (m1) {
        const dd = String(m1[1]).padStart(2, '0');
        const mm = String(m1[2]).padStart(2, '0');
        const yyyy = m1[3];
        return `${yyyy}-${mm}-${dd}`;
      }

      const parsed = new Date(s);
      if (!isNaN(parsed)) {
        const y = parsed.getFullYear();
        const m = String(parsed.getMonth() + 1).padStart(2, '0');
        const d = String(parsed.getDate()).padStart(2, '0');
        return `${y}-${m}-${d}`;
      }

      return null;
    }

    async function loadFincas() {
      const { data, error } = await supabase.from('fincas').select('id,nombre');
      if (error) throw error;
      fincasMap.clear();
      (data || []).forEach(f => fincasMap.set(f.id, f.nombre));
    }

    function resolveFincaId(nombreFinca) {
      const needle = norm(nombreFinca);
      if (!needle) return null;
      for (const [id, nombre] of fincasMap.entries()) {
        if (norm(nombre) === needle) return id;
      }
      for (const [id, nombre] of fincasMap.entries()) {
        const n = norm(nombre);
        if (n.includes(needle) || needle.includes(n)) return id;
      }
      return null;
    }

    function makeFingerprint(r) {
      return [
        r.fecha,
        r.finca_id,
        r.bloque_id ?? '',
        r.lat,
        r.lon,
        (r.tecnico ?? '').trim().toLowerCase()
      ].join('|');
    }

    // columnas aceptadas
    const COLS = {
      fecha: ['3_fecha', 'fecha', 'date'],
      finca: ['4_finca', 'finca', 'farm'],
      tecnico: ['15_tecnico', 'tecnico', 't√©cnico', 'encuestador'],
      lat: ['lat_6_geolocalizacion', 'latitud', 'lat', 'latitude'],
      lon: ['long_6_geolocalizacion', 'lon', 'long', 'longitud', 'longitude'],
      brotes: ['10_brotes_hojas', 'brotes', 'brote'],
      hojas: ['11_hojas_adultas', 'hojas_adultas', 'adultas', 'hojas'],
      limones: ['12_limones', 'limones', 'frutos', 'limon'],
      botones: ['13_botones_florales', 'botones', 'botones_florales', 'florales'],
      yemas: ['14_yemas', 'yemas']
    };

    function buildHeaderIndex(headers) {
      const hNorm = headers.map(h => norm(h));

      function findIndex(keys) {
        for (const k of keys) {
          const kn = norm(k);
          const i = hNorm.findIndex(h => h === kn || h.includes(kn));
          if (i !== -1) return i;
        }
        return -1;
      }

      return {
        fecha: findIndex(COLS.fecha),
        finca: findIndex(COLS.finca),
        tecnico: findIndex(COLS.tecnico),
        lat: findIndex(COLS.lat),
        lon: findIndex(COLS.lon),
        brotes: findIndex(COLS.brotes),
        hojas: findIndex(COLS.hojas),
        limones: findIndex(COLS.limones),
        botones: findIndex(COLS.botones),
        yemas: findIndex(COLS.yemas)
      };
    }

    function missingRequired(idx) {
      const req = ['fecha', 'finca', 'lat', 'lon'];
      return req.filter(k => idx[k] === -1);
    }

    async function parseCSVFile(file) {
      return new Promise((resolve, reject) => {
        Papa.parse(file, {
          header: true,
          skipEmptyLines: true,
          worker: true,
          complete: resolve,
          error: reject
        });
      });
    }

    function csvToRegistros(results) {
      const headers = results.meta.fields || [];
      const idx = buildHeaderIndex(headers);
      const miss = missingRequired(idx);
      if (miss.length) throw new Error(`Faltan columnas requeridas: ${miss.join(', ')}`);

      const regs = [];
      const errs = [];

      for (const row of results.data) {
        const fecha = toISODate(row[headers[idx.fecha]]);
        const fincaNombre = row[headers[idx.finca]];
        const lat = toNumberFloat(row[headers[idx.lat]]);
        const lon = toNumberFloat(row[headers[idx.lon]]);
        const tecnico = idx.tecnico !== -1 ? String(row[headers[idx.tecnico]] ?? '').trim() : '';

        const finca_id = resolveFincaId(fincaNombre);

        if (!fecha) { if (errs.length < MAX_ERR_PREVIEW) errs.push(`Fecha inv√°lida: ${row[headers[idx.fecha]]}`); continue; }
        if (lat == null || lon == null) { if (errs.length < MAX_ERR_PREVIEW) errs.push(`Lat/Lon inv√°lidos en ${fecha}`); continue; }
        if (!finca_id) { if (errs.length < MAX_ERR_PREVIEW) errs.push(`Finca no encontrada (${fincaNombre}) en ${fecha}`); continue; }

        regs.push({
          fecha,
          finca_id,
          bloque_id: null,
          lat,
          lon,
          tecnico,
          brotes_pos: idx.brotes !== -1 ? toInt(row[headers[idx.brotes]], 0) : 0,
          hojas_adultas_pos: idx.hojas !== -1 ? toInt(row[headers[idx.hojas]], 0) : 0,
          limones_pos: idx.limones !== -1 ? toInt(row[headers[idx.limones]], 0) : 0,
          botones_pos: idx.botones !== -1 ? toInt(row[headers[idx.botones]], 0) : 0,
          yemas_pos: idx.yemas !== -1 ? toInt(row[headers[idx.yemas]], 0) : 0
        });
      }

      return { registros: regs, errores: errs };
    }

    async function parseXLSXFile(file) {
      const buf = await file.arrayBuffer();
      const wb = XLSX.read(buf, { type: 'array', cellDates: true });
      const sheet = wb.Sheets[wb.SheetNames[0]];
      const rows = XLSX.utils.sheet_to_json(sheet, { header: 1, defval: '' });

      if (!rows || rows.length < 2) return { registros: [], errores: ['El Excel no tiene filas suficientes.'] };

      const headers = rows[0].map(h => String(h).trim());
      const idx = buildHeaderIndex(headers);
      const miss = missingRequired(idx);
      if (miss.length) throw new Error(`Faltan columnas requeridas: ${miss.join(', ')}`);

      const regs = [];
      const errs = [];

      for (let i = 1; i < rows.length; i++) {
        const r = rows[i];
        if (!r || r.every(v => String(v).trim() === '')) continue;

        const fecha = toISODate(r[idx.fecha]);
        const fincaNombre = r[idx.finca];
        const lat = toNumberFloat(r[idx.lat]);
        const lon = toNumberFloat(r[idx.lon]);
        const tecnico = idx.tecnico !== -1 ? String(r[idx.tecnico] ?? '').trim() : '';

        const finca_id = resolveFincaId(fincaNombre);

        if (!fecha) { if (errs.length < MAX_ERR_PREVIEW) errs.push(`Fila ${i+1}: fecha inv√°lida`); continue; }
        if (lat == null || lon == null) { if (errs.length < MAX_ERR_PREVIEW) errs.push(`Fila ${i+1}: lat/lon inv√°lidos`); continue; }
        if (!finca_id) { if (errs.length < MAX_ERR_PREVIEW) errs.push(`Fila ${i+1}: finca no encontrada (${fincaNombre})`); continue; }

        regs.push({
          fecha,
          finca_id,
          bloque_id: null,
          lat,
          lon,
          tecnico,
          brotes_pos: idx.brotes !== -1 ? toInt(r[idx.brotes], 0) : 0,
          hojas_adultas_pos: idx.hojas !== -1 ? toInt(r[idx.hojas], 0) : 0,
          limones_pos: idx.limones !== -1 ? toInt(r[idx.limones], 0) : 0,
          botones_pos: idx.botones !== -1 ? toInt(r[idx.botones], 0) : 0,
          yemas_pos: idx.yemas !== -1 ? toInt(r[idx.yemas], 0) : 0
        });
      }

      return { registros: regs, errores: errs };
    }

    async function procesarArchivo(file) {
      const ext = (file.name.split('.').pop() || '').toLowerCase();
      if (ext === 'csv') {
        const results = await parseCSVFile(file);
        return csvToRegistros(results);
      }
      if (ext === 'xlsx') {
        return await parseXLSXFile(file);
      }
      throw new Error('Tipo de archivo no soportado. Usa .csv o .xlsx');
    }

    async function upsertRegistros(registros) {
      const chunks = chunkArray(registros, BATCH_SIZE);
      let done = 0;

      for (let i = 0; i < chunks.length; i++) {
        toast(`Subiendo lote ${i+1}/${chunks.length}... (${done}/${registros.length})`);
        const { error } = await supabase.from('monitoreos')
          .upsert(chunks[i], { onConflict: 'fingerprint' });
        if (error) throw error;
        done += chunks[i].length;
      }
      return done;
    }

    async function procesarYSubir(file) {
      toast('Cargando fincas...');
      await loadFincas();

      toast('Procesando archivo...');
      const { registros, errores } = await procesarArchivo(file);

      if (!registros.length) {
        const extra = errores.length ? `<br><small>Ejemplos:<br>- ${errores.join('<br>- ')}</small>` : '';
        throw new Error('No hay filas v√°lidas.' + extra);
      }

      registros.forEach(r => r.fingerprint = makeFingerprint(r));

      const n = await upsertRegistros(registros);

      const warn = errores.length
        ? `<br><small>Filas omitidas: ${errores.length}. Ejemplos:<br>- ${errores.join('<br>- ')}</small>`
        : '';

      toast(`‚úÖ Listo. Filas guardadas: ${n}.${warn}`);
    }

    // UI events
    selectFileBtn.addEventListener('click', (e) => { e.preventDefault(); fileInput.click(); });

    dropZone.addEventListener('click', () => fileInput.click());
    dropZone.addEventListener('dragover', (e) => e.preventDefault());
    dropZone.addEventListener('drop', (e) => {
      e.preventDefault();
      const file = e.dataTransfer.files[0];
      if (!file) return;
      const low = file.name.toLowerCase();
      const ok = low.endsWith('.csv') || low.endsWith('.xlsx');
      if (!ok) return alert('Solo CSV o XLSX');
      fileInput.files = e.dataTransfer.files;
      fileSelected.textContent = `üìÑ ${file.name}`;
      btnSubir.disabled = false;
    });

    fileInput.addEventListener('change', () => {
      if (fileInput.files.length) {
        fileSelected.textContent = `üìÑ ${fileInput.files[0].name}`;
        btnSubir.disabled = false;
      } else {
        fileSelected.textContent = 'Ning√∫n archivo';
        btnSubir.disabled = true;
      }
    });

    btnSubir.addEventListener('click', async () => {
      const file = fileInput.files[0];
      if (!file) return;

      btnSubir.disabled = true;
      try {
        toast('Iniciando...');
        await procesarYSubir(file);
      } catch (err) {
        console.error(err);
        toast(`‚ùå Error: ${err.message || err}`, true);
      } finally {
        fileInput.value = '';
        fileSelected.textContent = 'Ning√∫n archivo';
        btnSubir.disabled = true;
      }
    });
  </script>
</body>
</html>


    
